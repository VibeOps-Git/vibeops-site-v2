{% extends "base.html" %}
{% block title %}Reportly â€” Chat â†’ Word (pixel-true){% endblock %}

{% block extra_head %}
  <link rel="stylesheet" href="{{ url_for('static', filename='reportly.css') }}">
{% endblock %}

{% block content %}
<section class="page-hero page-hero--slim">
  <div class="hero-container">
    <h1 class="hero-title">Reportly</h1>
    <p class="hero-sub">
      Chat-first report generation into your Word (or PDF â†’ Word) template â€” live, pixel-true preview.
      {% if state and state.filename %}
        <span class="doc-pill">{{ state.filename }}</span>
      {% endif %}
    </p>
  </div>
</section>

<div class="row chat-layout">
  <!-- LEFT: Chat + toggles + upload -->
  <div class="col left">
    <div class="card chat-card" data-aos="fade-up">
      <div class="chat-card-inner">
        <h2 class="card-title">Chat</h2>

        {% if state %}
        <div id="chatLog" class="chat-log">
          {% for m in state.messages %}
          <div class="chat-msg {{ 'user' if m.role=='user' else 'assistant' }}">
            <div class="bubble">{{ m.content }}</div>
          </div>
          {% endfor %}
        </div>

        <div class="chat-input-wrap">
          <form id="chatForm" class="chat-form" action="javascript:void(0);" novalidate>
            <div class="composer">
              <!-- Left: plus -->
              <button type="button" class="icon-btn composer-plus" id="plus-menu-btn" aria-label="More actions">
                <!-- plus icon -->
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                  <path d="M12 5v14M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </button>

              <!-- Textarea -->
              <textarea id="chatInput" name="message" rows="1"
                placeholder="Message Reportlyâ€¦"></textarea>

              <!-- Right: paperclip + send -->
              <div class="composer-actions">
                <button type="button" class="icon-btn" id="print-open" aria-label="Attach .print">
                  <!-- paperclip -->
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path d="M21 15V7a5 5 0 0 0-10 0v10a3 3 0 0 0 6 0V8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button class="icon-btn send-btn" type="submit" aria-label="Send" formnovalidate>
                  <!-- send arrow -->
                  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true">
                    <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M22 2l-7 20-4-9-9-4 20-7z" stroke="currentColor" stroke-width="2" stroke-linejoin="round" fill="none"/>
                  </svg>
                </button>
              </div>
            </div>

            <!-- Plus menu (anchored to the plus button) -->
            <div class="plus-menu" id="plus-menu" hidden>
              <div class="plus-menu-section">
                <h3>Quick actions</h3>
                <button type="button" class="btn secondary" onclick="preset('Generate full report content aligned to the template.')">Generate all</button>
                <button type="button" class="btn secondary" onclick="preset('Only update Executive Summary with risks and 3 recommendations.')">Only Exec Summary</button>
                <button type="button" class="btn secondary" onclick="preset('Replace Findings section with a detailed analysis and a 5-row table.')">Replace Findings</button>
              </div>

              <div class="plus-menu-section">
                <h3>Settings</h3>
                <label>Length:
                  <select name="length_mode" id="lengthMode">
                    <option value="concise">Concise</option>
                    <option value="standard" selected>Standard</option>
                    <option value="detailed">Detailed</option>
                    <option value="custom">Custom (words)</option>
                  </select>
                </label>
                <input type="number" min="50" step="50" id="customWords" name="custom_words"
                      placeholder="Words" class="custom-words" style="display:none">
                <label class="checkbox">
                  <input type="checkbox" id="includeInContext" name="include_in_context" {% if state.include_in_context %}checked{% endif %}>
                  Include uploaded document text as AI context
                </label>
                <label class="checkbox">
                  <input type="checkbox" id="stripExisting" name="strip_existing" {% if state.strip_existing %}checked{% endif %}>
                  Strip existing body when composing
                </label>
              </div>

              <div class="plus-menu-section">
                <h3>Upload / Replace Template (.docx)</h3>
                <form action="{{ url_for('reportly_home') }}" method="post" enctype="multipart/form-data" class="upload-form">
                  <label class="file">
                    <span class="file-cta">Choose .docx or .pdf</span>
                    <input type="file" name="file" accept=".docx,.pdf" required>
                  </label>
                  <button class="btn" type="submit">Upload</button>
                </form>
              </div>
            </div>
          </form>
        </div>
        <div class="chat-footer">
          <a class="btn secondary" href="{{ url_for('reportly_download_current', doc_id=state.doc_id) }}">Download DOCX</a>
          <a class="btn secondary" href="{{ url_for('reportly_preview', doc_id=state.doc_id) }}?download=1">Download PDF</a>
        </div>
        {% else %}
        <p class="muted">Upload a Word template to start. Then chat to update it with live preview.</p>
        <form action="{{ url_for('reportly_home') }}" method="post" enctype="multipart/form-data" class="upload-form">
          <label class="file">
            <span class="file-cta">Choose .docx or .pdf</span>
            <input type="file" name="file" accept=".docx" required>
          </label>
          <button class="btn" type="submit">Upload</button>
        </form>
        {% endif %}
      </div>
    </div>

    <!-- LOGS: extracted sections -->
    <div class="card" id="doc-logs" data-aos="fade-up" style="margin-top:12px;">
      <div class="card-header row between">
        <h2 class="card-title" style="margin:0;">Logs</h2>
        {% if state %}
          <small class="muted">doc: {{ state.filename }}</small>
        {% endif %}
      </div>
      <div class="log-body">
        <div class="log-line muted">waiting for documentâ€¦</div>
      </div>
    </div>
  </div>

  <!-- RIGHT: Preview + Review -->
  <div class="col right">
    <div class="card sticky" data-aos="fade-up" data-aos-delay="50">
      <div class="editor-head">
        <h2 class="card-title">Preview (Exact, PDF)</h2>
        <div class="preview-menu">
          <button type="button" class="btn secondary menu-btn">â˜°</button>
          <div class="preview-menu-content" style="display: none;">
            <button id="accept-all" class="btn secondary" type="button">Accept all</button>
            <button id="reject-all" class="btn secondary" type="button">Reject all</button>
            <a class="btn secondary" id="pv-open" href="{{ url_for('reportly_preview', doc_id=state.doc_id) }}" target="_blank">Open</a>
          </div>
        </div>
      </div>

      {% if state %}
      <div class="viewer-bar">
        <div class="muted">{{ state.filename }} â†’ PDF</div>
      </div>

      <div class="preview-wrap">
        <div class="loading-veil" id="pv-loading"><span class="muted">Renderingâ€¦</span></div>
        <iframe id="pdfFrame" class="preview-frame" title="Exact Preview" src="{{ url_for('reportly_preview', doc_id=state.doc_id) }}?_ts={{ range(1)|list|first }}"></iframe>
      </div>
      <p class="muted">New AI text is highlighted in green until you Accept.</p>
      <div class="review-bar">
        <div class="review-title">Pending changes</div>
        <div id="review-list" class="review-list empty">
          <span class="muted">No pending changes.</span>
        </div>
      </div>
      {% else %}
      <div class="outline">
        <p class="muted">Upload a document to see its preview here.</p>
      </div>
      {% endif %}
    </div>
  </div>
</div>

<!-- .print modal -->
<div id="print-modal" aria-hidden="true">
  <div class="box">
    <div class="row between">
      <h3 class="box-title">Collect input materials (.print)</h3>
      <button id="print-close" class="btn secondary" type="button">Close</button>
    </div>

    <div class="row">
      <label for="print-depth" class="muted">Depth</label>
      <input id="print-depth" type="number" min="0" max="50" value="2" style="width:80px;">
      <button id="print-run" class="btn" type="button">Select folder &amp; run</button>
      <span id="print-status" class="muted"></span>
    </div>

    <details open>
      <summary><strong>Folder tree</strong></summary>
      <textarea id="print-tree" placeholder="Tree will appear hereâ€¦"></textarea>
      <div class="row" style="justify-content:flex-start;">
        <button id="copy-tree" class="btn secondary" type="button">Copy Tree</button>
        <button id="download-tree" class="btn secondary" type="button">Download tree.txt</button>
      </div>
    </details>

    <details>
      <summary><strong>File contents</strong></summary>
      <textarea id="print-contents" placeholder="File contents will appear hereâ€¦"></textarea>
      <div class="row" style="justify-content:flex-start;">
        <button id="copy-contents" class="btn secondary" type="button">Copy Contents</button>
        <button id="download-contents" class="btn secondary" type="button">Download contents.txt</button>
        <button id="send-to-chat" class="btn btn-accent" type="button">Attach to chat</button>
      </div>
    </details>

    <p class="muted" style="margin-top:10px;">
      Tip: If your browser doesnâ€™t allow folder access, use the
      <a href="/download">desktop .print app</a>.
    </p>
  </div>
  <script id="reportly-state" type="application/json">
    {{ {'doc_id': (state.doc_id if state else None)} | tojson }}
  </script>
</div>

{% endblock %}

{% block extra_scripts %}
  {% if state %}
  <script>
    // Auto-grow textarea (like ChatGPT)
    const composer = document.querySelector('.composer');
    const ta = document.getElementById('chatInput');
    const form = document.getElementById('chatForm');
    const plusBtn = document.getElementById('plus-menu-btn');
    const plusMenu = document.getElementById('plus-menu');
    const lengthMode = document.getElementById('lengthMode');
    const customWords = document.getElementById('customWords');
    const docId = "{{ state.doc_id }}";

    // Auto-resize textarea
    function autoresize() {
      if (!ta) return;
      ta.style.height = '0px';
      const h = Math.min(ta.scrollHeight, 220);
      ta.style.height = h + 'px';
    }
    ta?.addEventListener('input', autoresize);
    window.addEventListener('load', autoresize);

    // Enter to send, Shift+Enter for newline
    ta?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        form.requestSubmit(document.querySelector('.send-btn'));
      }
    });

    // Form submission
    form?.addEventListener('submit', async (e) => {
      e.preventDefault();
      const msg = (ta.value || '').trim();
      if (!msg) return;

      const chatLog = document.getElementById('chatLog');
      function appendMsg(role, content) {
        const wrap = document.createElement('div');
        wrap.className = 'chat-msg ' + (role === 'user' ? 'user' : 'assistant');
        const bubble = document.createElement('div');
        bubble.className = 'bubble';
        bubble.textContent = content;
        wrap.appendChild(bubble);
        chatLog.appendChild(wrap);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      appendMsg('user', msg);
      const fd = new FormData();
      fd.append('message', msg);
      fd.append('length_mode', lengthMode.value);
      if (customWords.value && lengthMode.value === 'custom') {
        fd.append('custom_words', customWords.value);
      }

      ta.value = '';
      autoresize();
      try {
        const res = await fetch(`/reportly/chat/${docId}`, { method: 'POST', body: fd });
        const resp = await res.json();
        if (!res.ok) throw new Error(resp?.error || 'HTTP ' + res.status);
        appendMsg('assistant', resp.assistant_message || 'Proposed changes.');
      } catch (err) {
        appendMsg('assistant', 'âš ï¸Ž ' + err.message);
      }
    });

    // Plus menu toggle + click-away close
    plusBtn?.addEventListener('click', () => {
      const hidden = plusMenu.hasAttribute('hidden');
      if (hidden) plusMenu.removeAttribute('hidden');
      else plusMenu.setAttribute('hidden', '');
    });
    document.addEventListener('click', (e) => {
      if (!plusMenu || !plusBtn) return;
      if (!plusMenu.contains(e.target) && !plusBtn.contains(e.target)) {
        plusMenu.setAttribute('hidden', '');
      }
    });

    // Show/hide custom words input
    function updateCustom() {
      if (customWords) customWords.style.display = (lengthMode?.value === 'custom' ? 'block' : 'none');
    }
    lengthMode?.addEventListener('change', updateCustom);
    updateCustom();

    // Focus textarea on load
    ta?.focus();
  </script>
  {% endif %}

  <script>
    (function(){
      // Preview menu toggle
      const previewMenuBtn = document.querySelector('.preview-menu .menu-btn');
      const previewMenuContent = document.querySelector('.preview-menu-content');
      previewMenuBtn?.addEventListener('click', () => {
        previewMenuContent.style.display = previewMenuContent.style.display === 'none' ? 'block' : 'none';
      });
      document.addEventListener('click', (e) => {
        if (!previewMenuContent.contains(e.target) && !previewMenuBtn.contains(e.target)) {
          previewMenuContent.style.display = 'none';
        }
      });
    })();
  </script>

  {% if state %}
  <script>
    const docIdPreset = "{{ state.doc_id }}";
    function preset(text){
      const ta = document.getElementById('chatInput');
      ta.value = text; ta.focus();
    }

    /* PDF refresh on SSE */
    (function(){
      const frame = document.getElementById('pdfFrame');
      const veil = document.getElementById('pv-loading');
      function refresh(){
        if (!frame) return;
        const base = frame.src.split("?")[0];
        veil?.classList.add('on');
        frame.src = base + "?_ts=" + Date.now();
      }
      frame?.addEventListener('load', ()=> veil?.classList.remove('on'));
      if (window.EventSource){
        const es = new EventSource(`/reportly/stream/${docId}`);
        es.addEventListener("update", ev => {
          try{ const d = JSON.parse(ev.data||"{}"); if (d.preview==="ready") refresh(); }catch(_){}
        });
      }
    })();

    /* Chat + toggles */
    (function(){
      const chatForm = document.getElementById("chatForm");
      const chatLog = document.getElementById("chatLog");
      const chatInput = document.getElementById("chatInput");
      const lengthMode = document.getElementById("lengthMode");
      const customWords = document.getElementById("customWords");
      const includeInContext = document.getElementById("includeInContext");
      const stripExisting = document.getElementById("stripExisting");

      function updateCustomVisibility(){
        customWords.style.display = (lengthMode.value === "custom" ? "inline-block" : "none");
      }
      lengthMode.addEventListener("change", updateCustomVisibility); updateCustomVisibility();

      function appendMsg(role, content){
        const wrap = document.createElement("div");
        wrap.className = "chat-msg " + (role === "user" ? "user" : "assistant");
        const bubble = document.createElement("div");
        bubble.className = "bubble";
        bubble.textContent = content;
        wrap.appendChild(bubble);
        chatLog.appendChild(wrap);
        chatLog.scrollTop = chatLog.scrollHeight;
      }

      async function postForm(url, data){
        const res = await fetch(url, { method: "POST", body: data });
        let j = null; try{ j = await res.json(); }catch(e){}
        if (!res.ok){ throw new Error((j && j.error) ? j.error : ("HTTP " + res.status)); }
        return j || {};
      }

      chatForm.addEventListener("submit", async (e)=>{
        e.preventDefault();
        const msg = (chatInput.value || "").trim();
        if (!msg) return;
        appendMsg("user", msg);

        const fd = new FormData();
        fd.append("message", msg);
        fd.append("length_mode", lengthMode.value);
        if (customWords.value && lengthMode.value === "custom"){
          fd.append("custom_words", customWords.value);
        }

        chatInput.value = "";
        try{
          const resp = await postForm(`/reportly/chat/${docId}`, fd);
          appendMsg("assistant", resp.assistant_message || "Proposed changes.");
        }catch(err){
          appendMsg("assistant", "âš ï¸Ž " + err.message);
        }
      });

      async function pushState(){
        const fd = new FormData();
        fd.append("include_in_context", includeInContext.checked ? "1" : "0");
        fd.append("strip_existing",     stripExisting.checked ? "1" : "0");
        try{ await postForm(`/reportly/state/${docId}`, fd); }catch(_){}
      }
      includeInContext.addEventListener("change", pushState);
      stripExisting.addEventListener("change", pushState);

      chatInput?.focus();
    })();
  </script>
  {% endif %}

  <!-- Update file input label -->
  <script>
    (function(){
      document.querySelectorAll('.upload-form input[type="file"]').forEach(input=>{
        const labelEl = input.closest('label')?.querySelector('.file-cta');
        if (!labelEl) return;
        input.addEventListener('change', ()=>{
          const f = input.files && input.files[0];
          if (f) labelEl.textContent = f.name;
        });
      });
    })();
  </script>

  <!-- Review bar + .print modal -->
  <script>
    (function(){
      const stateEl = document.getElementById('reportly-state');
      let s = null;
      try { s = JSON.parse(stateEl?.textContent || '{}').doc_id || null; } catch {}
      if (!s) return;
      // ...

      // Review list
      const listEl = document.getElementById('review-list');
      const acceptAll = document.getElementById('accept-all');
      const rejectAll = document.getElementById('reject-all');

      async function fetchPending(){
        const r = await fetch(`/reportly/pending/${s}`);
        const j = await r.json();
        render(j.pending||[]);
      }

      function render(items){
        listEl.innerHTML = '';
        if (!items.length){
          listEl.classList.add('empty');
          listEl.innerHTML = '<span class="muted">No pending changes.</span>';
          return;
        }
        listEl.classList.remove('empty');
        for (const c of items){
          const row = document.createElement('div');
          row.className = 'review-item';
          row.innerHTML = `
            <div class="review-meta">
              <div class="review-title-small">${c.title || 'Untitled section'}</div>
              <div class="muted">level ${c.level} Â· ${(c.blocks && c.blocks.length) || 0} block(s)</div>
            </div>
            <div class="review-ops">
              <button data-id="${c.change_id}" class="btn secondary btn-accept">Accept</button>
              <button data-id="${c.change_id}" class="btn secondary btn-reject">Reject</button>
            </div>
          `;
          listEl.appendChild(row);
        }
        bindOps();
      }

      function bindOps(){
        listEl.querySelectorAll('.btn-accept').forEach(b=>{
          b.onclick = async ()=>{
            const id = b.getAttribute('data-id');
            await fetch(`/reportly/review/${s}/accept`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({change_id:id})});
            fetchPending();
          };
        });
        listEl.querySelectorAll('.btn-reject').forEach(b=>{
          b.onclick = async ()=>{
            const id = b.getAttribute('data-id');
            await fetch(`/reportly/review/${s}/reject`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({change_id:id})});
            fetchPending();
          };
        });
      }

      acceptAll?.addEventListener('click', async ()=>{
        await fetch(`/reportly/review/${s}/accept`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({all:true})});
        fetchPending();
      });
      rejectAll?.addEventListener('click', async ()=>{
        await fetch(`/reportly/review/${s}/reject`, {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({all:true})});
        fetchPending();
      });

      // Refresh pending list when preview rebuilds
      if (window.EventSource){
        const es = new EventSource(`/reportly/stream/${s}`);
        es.addEventListener("update", ev => {
          try{ const d = JSON.parse(ev.data||"{}"); if (d.preview==="ready") fetchPending(); }catch(_){}
        });
      }
      fetchPending();

      // .print modal
      const modal = document.getElementById('print-modal');
      const openBtn = document.getElementById('print-open');
      const closeBtn = document.getElementById('print-close');
      const runBtn = document.getElementById('print-run');
      const depthInput = document.getElementById('print-depth');
      const statusEl = document.getElementById('print-status');
      const treeEl = document.getElementById('print-tree');
      const contentsEl = document.getElementById('print-contents');
      const copyTreeBtn = document.getElementById('copy-tree');
      const copyContentsBtn = document.getElementById('copy-contents');
      const dlTreeBtn = document.getElementById('download-tree');
      const dlContentsBtn = document.getElementById('download-contents');
      const sendBtn = document.getElementById('send-to-chat');

      function show(){ modal.style.display = 'block'; }
      function hide(){ modal.style.display = 'none'; }

      openBtn?.addEventListener('click', ()=>{
        if (!('showDirectoryPicker' in window)) {
          alert('Your browser may show a folder file picker instead of native access.');
        }
        show();
      });
      closeBtn?.addEventListener('click', hide);
      modal.addEventListener('click', (e)=>{ if (e.target === modal) hide(); });
      document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') hide(); });

      const SKIP_DIRS = new Set(['.git','__pycache__','node_modules']);
      const TEXT_EXTS = new Set([
        '.txt','.md','.markdown','.py','.js','.ts','.tsx','.jsx','.json',
        '.yml','.yaml','.ini','.cfg','.toml','.css','.scss','.sass',
        '.html','.htm','.jinja','.jinja2',
        '.sh','.bat','.ps1','.rb','.php','.java','.c','.cpp','.h','.hpp'
      ]);
      const MAX_BYTES = 300_000;
      const extOf = n => { const i = n.lastIndexOf('.'); return i>=0 ? n.slice(i).toLowerCase() : ''; };

      async function* walkFSDirectoryHandle(dirHandle, basePath = '', depth = 2){
        if (depth < 0) return;
        for await (const entry of dirHandle.values()){
          const rel = basePath ? `${basePath}/${entry.name}` : entry.name;
          if (entry.kind === 'directory'){
            if (SKIP_DIRS.has(entry.name)) continue;
            yield {type:'dir', path: rel};
            const sub = await dirHandle.getDirectoryHandle(entry.name);
            yield* walkFSDirectoryHandle(sub, rel, depth-1);
          } else {
            yield {type:'file', path: rel, handle: entry};
          }
        }
      }

      async function readFileHandle(fileHandle){
        const file = await fileHandle.getFile();
        if (file.size > MAX_BYTES) return null;
        const isText = TEXT_EXTS.has(extOf(file.name)) || file.type.startsWith('text/') || file.type === '';
        if (!isText) return null;
        const buf = await file.arrayBuffer();
        if (buf.byteLength > MAX_BYTES) return null;
        try{ return new TextDecoder('utf-8', {fatal:false}).decode(buf); }catch{ return null; }
      }

      async function runCollectorWithDirectoryPicker(maxDepth){
        const dir = await window.showDirectoryPicker({mode:'read'});
        const treeLines = [];
        const contentChunks = [];
        for await (const item of walkFSDirectoryHandle(dir, '', maxDepth)){
          if (item.type === 'dir'){
            treeLines.push(`ðŸ“ ${item.path}/`);
          } else {
            treeLines.push(`ðŸ“„ ${item.path}`);
            const txt = await readFileHandle(item.handle);
            if (txt !== null){
              contentChunks.push(`\n--- Contents of ${item.path} ---\n${txt}`);
            }
          }
        }
        return { tree: treeLines.join('\n'), contents: contentChunks.join('\n') };
      }

      function getFallbackInput(){
        let input = document.getElementById('webkit-dir-input');
        if (input) return input;
        input = document.createElement('input');
        input.type = 'file';
        input.id = 'webkit-dir-input';
        input.setAttribute('webkitdirectory','');
        input.setAttribute('multiple','');
        input.style.display = 'none';
        document.body.appendChild(input);
        return input;
      }

      async function runCollectorWithFileInput(maxDepth){
        const input = getFallbackInput();
        return new Promise(resolve=>{
          input.onchange = ()=>{
            const files = Array.from(input.files || []);
            files.sort((a,b)=> (a.webkitRelativePath||a.name).localeCompare(b.webkitRelativePath||b.name));
            const treeLines = [];
            const contentChunks = [];
            for (const file of files){
              const rel = file.webkitRelativePath || file.name;
              const parts = rel.split('/');
              const depth = parts.length - 1;
              if (depth > maxDepth) continue;
              if (parts.some(p => SKIP_DIRS.has(p))) continue;
              treeLines.push(`ðŸ“„ ${rel}`);
            }
            (async ()=>{
              for (const file of files){
                const rel = file.webkitRelativePath || file.name;
                const parts = rel.split('/');
                const depth = parts.length - 1;
                if (depth > maxDepth) continue;
                if (parts.some(p => SKIP_DIRS.has(p))) continue;
                const ext = extOf(file.name);
                const isText = TEXT_EXTS.has(ext) || file.type.startsWith('text/') || file.type === '';
                if (!isText) continue;
                if (file.size > MAX_BYTES) continue;
                const txt = await file.text();
                contentChunks.push(`\n--- Contents of ${rel} ---\n${txt}`);
              }
              resolve({ tree: treeLines.join('\n'), contents: contentChunks.join('\n') });
            })();
          };
          input.click();
        });
      }

      async function runPrintCollector(maxDepth){
        if ('showDirectoryPicker' in window){
          try { return await runCollectorWithDirectoryPicker(maxDepth); }
          catch(e){ /* cancel */ }
        }
        return await runCollectorWithFileInput(maxDepth);
      }

      runBtn?.addEventListener('click', async ()=>{
        statusEl.textContent = 'Runningâ€¦';
        try {
          const maxDepth = Math.max(0, Math.min(50, parseInt(depthInput.value || '2', 10)));
          const { tree, contents } = await runPrintCollector(maxDepth);
          treeEl.value = tree || '';
          contentsEl.value = contents || '';
          statusEl.textContent = 'Done.';
        } catch (e) {
          statusEl.textContent = (e && e.message) ? e.message : 'Failed.';
        }
      });

      copyTreeBtn?.addEventListener('click', ()=>{ treeEl.select(); document.execCommand('copy'); });
      copyContentsBtn?.addEventListener('click', ()=>{ contentsEl.select(); document.execCommand('copy'); });

      function downloadText(filename, text){
        const blob = new Blob([text||''], {type:'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.download = filename; a.click();
        URL.revokeObjectURL(url);
      }
      dlTreeBtn?.addEventListener('click', ()=> downloadText('tree.txt', treeEl.value) );
      dlContentsBtn?.addEventListener('click', ()=> downloadText('contents.txt', contentsEl.value) );

      sendBtn?.addEventListener('click', async ()=>{
        const payload = { tree: treeEl.value || '', contents: contentsEl.value || '' };
        statusEl.textContent = 'Uploadingâ€¦';
        try{
          const res = await fetch('/api/print/upload', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify(payload)
          });
          const data = await res.json();
          if (!res.ok) throw new Error(data?.message || 'Upload failed');
          statusEl.textContent = data.message || 'Uploaded';
          const chatInput = document.getElementById('chatInput');
          if (chatInput && data.id){
            chatInput.value = (chatInput.value ? chatInput.value + '\n' : '') + `[print:${data.id}]`;
            chatInput.focus();
          }
        }catch(e){
          statusEl.textContent = e.message || 'Upload failed';
        }
      });
    })();
  </script>

  {% if state %}
  <script>
  (() => {
    if (!document.body.classList.contains('has-doc')) return;
    const grid = document.querySelector('.row.chat-layout');
    if (!grid) return;

    // create gutter between the two .col panes
    const cols = Array.from(grid.children).filter(n => n.classList?.contains('col'));
    if (cols.length < 2) return;
    let gutter = document.getElementById('split-gutter');
    if (!gutter){
      gutter = document.createElement('div');
      gutter.id = 'split-gutter';
      gutter.className = 'gutter';
      gutter.setAttribute('role','separator');
      gutter.setAttribute('aria-orientation','vertical');
      cols[0].after(gutter);
    }

    // persist split in CSS var --split
    const KEY = 'reportly-split-v1';
    const clamp = (v,a,b)=> Math.min(b, Math.max(a,v));
    const setSplit = pct => {
      const v = clamp(Math.round(pct), 25, 75);
      document.documentElement.style.setProperty('--split', String(v));
      localStorage.setItem(KEY, String(v));
    };
    const saved = Number(localStorage.getItem(KEY));
    if (!Number.isNaN(saved)) setSplit(saved);

    // drag handlers
    let dragging = false;
    const start = () => { dragging = true; gutter.classList.add('is-dragging'); document.body.style.userSelect='none'; };
    const move = (clientX) => {
      const r = grid.getBoundingClientRect();
      setSplit(((clientX - r.left) / r.width) * 100);
    };
    const stop = () => { if(!dragging) return; dragging=false; gutter.classList.remove('is-dragging'); document.body.style.userSelect=''; };

    gutter.addEventListener('mousedown', e => { start(); move(e.clientX); });
    window.addEventListener('mousemove', e => { if (dragging) move(e.clientX); });
    window.addEventListener('mouseup', stop);

    gutter.addEventListener('touchstart', e => { start(); move(e.touches[0].clientX); }, {passive:true});
    window.addEventListener('touchmove', e => { if (dragging){ e.preventDefault(); move(e.touches[0].clientX); }}, {passive:false});
    window.addEventListener('touchend', stop);

    // keyboard nudge
    gutter.tabIndex = 0;
    gutter.addEventListener('keydown', e => {
      const cur = Number(getComputedStyle(document.documentElement).getPropertyValue('--split')) || 58;
      const step = e.shiftKey ? 5 : 1;
      if (e.key === 'ArrowLeft'){ setSplit(cur - step); e.preventDefault(); }
      if (e.key === 'ArrowRight'){ setSplit(cur + step); e.preventDefault(); }
    });
  })();
  </script>
  {% endif %}

  <script>
    // Pick whatever selector matches your fixed top nav:
    const nav = document.querySelector('.reportly-header, .navbar, header');
    if (nav) document.documentElement.style.setProperty('--nav-h', nav.offsetHeight + 'px');
  </script>

  <script>
  (function(){
    const grid = document.querySelector('.row.chat-layout');
    if (!grid) return;

    const left = grid.querySelector('.col.left');
    const right = grid.querySelector('.col.right');
    if (!left || !right) return;

    // Insert gutter as the middle grid cell
    let gutter = grid.querySelector('#split-gutter');
    if (!gutter){
      gutter = document.createElement('div');
      gutter.id = 'split-gutter';
      gutter.className = 'gutter';
      gutter.setAttribute('role','separator');
      gutter.setAttribute('aria-orientation','vertical');
      left.after(gutter);
    }

    const KEY = 'reportly-split-v2';
    const setSplit = (pct) => {
      const v = Math.max(25, Math.min(75, Math.round(pct))); // clamp 25â€“75%
      document.documentElement.style.setProperty('--split', v + '%');
      try { localStorage.setItem(KEY, String(v)); } catch {}
    };

    // Restore saved split
    const saved = parseInt(localStorage.getItem(KEY), 10);
    if (!isNaN(saved)) setSplit(saved);

    // Drag handlers
    const onMove = (clientX) => {
      const r = grid.getBoundingClientRect();
      const pct = ((clientX - r.left) / r.width) * 100;
      setSplit(pct);
    };

    let dragging = false;
    const start = (clientX) => { dragging = true; gutter.classList.add('is-dragging'); document.body.style.userSelect='none'; onMove(clientX); };
    const stop  = () => { if (!dragging) return; dragging=false; gutter.classList.remove('is-dragging'); document.body.style.userSelect=''; };

    gutter.addEventListener('mousedown', e => start(e.clientX));
    window.addEventListener('mousemove', e => { if (dragging) onMove(e.clientX); });
    window.addEventListener('mouseup', stop);

    gutter.addEventListener('touchstart', e => start(e.touches[0].clientX), {passive:true});
    window.addEventListener('touchmove', e => { if (dragging){ e.preventDefault(); onMove(e.touches[0].clientX); }}, {passive:false});
    window.addEventListener('touchend', stop);

    // Keyboard nudge (accessible)
    gutter.tabIndex = 0;
    gutter.addEventListener('keydown', e => {
      const cur = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--split'), 10) || 58;
      const step = e.shiftKey ? 5 : 1;
      if (e.key === 'ArrowLeft')  { setSplit(cur - step); e.preventDefault(); }
      if (e.key === 'ArrowRight') { setSplit(cur + step); e.preventDefault(); }
    });
  })();
  </script>

  {% if state %}
  <script>
(function(){
  const docId = "{{ state.doc_id if state else '' }}";
  const bodyEl = document.querySelector('#doc-logs .log-body');
  if (!docId || !bodyEl) return;

  async function loadSections(){
    try{
      const r = await fetch(`/reportly/structure/${docId}`);
      const j = await r.json();
      if (!j.ok) throw new Error(j.error || 'Failed to load sections');
      const items = j.sections || [];
      if (!items.length){
        bodyEl.innerHTML = '<div class="log-line muted">No headings found. Using heuristics and preamble block.</div>';
        return;
      }
      bodyEl.innerHTML = items.map(s => {
        return `<div class="log-line">
          <span class="lvl">H${s.level}</span>
          <strong>${s.title.replace(/</g,'&lt;')}</strong>
          <span class="meta">Â· ${s.paragraphs} Â¶ Â· ${s.tables} tbl</span>
        </div>`;
      }).join('');
    }catch(e){
      bodyEl.innerHTML = `<div class="log-line">âš  ${e.message || e}</div>`;
    }
  }

  // initial
  loadSections();

  // refresh when preview rebuilds (often means structure changed after Accept)
  if (window.EventSource){
    const es = new EventSource(`/reportly/stream/${docId}`);
    es.addEventListener("update", ev => {
      try { const d = JSON.parse(ev.data||"{}"); if (d.preview==="ready") loadSections(); } catch {}
    });
  }
})();
  </script>
  {% endif %}

{% endblock %}
